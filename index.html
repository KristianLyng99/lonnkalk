<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Monthly Earnings Calculator with Calendar Integration</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }
    
    body {
      background-color: #f8f9fa;
      padding: 20px;
      color: #333;
    }
    
    .container {
      background-color: white;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      max-width: 800px;
      width: 100%;
      padding: 24px;
      margin: 0 auto;
    }
    
    h1 {
      color: #0e766e;
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 20px;
      text-align: center;
    }
    
    h2 {
      color: #0e766e;
      font-size: 18px;
      font-weight: 600;
      margin: 24px 0 12px 0;
    }
    
    .total-section {
      background-color: #e6fffa;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      margin-bottom: 24px;
    }
    
    .total-amount {
      font-size: 36px;
      font-weight: bold;
      color: #0e766e;
      margin-bottom: 5px;
    }
    
    .info-text {
      color: #718096;
      font-size: 14px;
      margin-bottom: 5px;
    }
    
    .tab-container {
      display: flex;
      margin-bottom: 20px;
      border-bottom: 1px solid #e2e8f0;
    }
    
    .tab {
      padding: 10px 20px;
      cursor: pointer;
      font-weight: 500;
      border-bottom: 2px solid transparent;
    }
    
    .tab.active {
      color: #0e766e;
      border-bottom: 2px solid #0e766e;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .shift-form {
      background-color: #f7fafc;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 20px;
    }
    
    .form-title {
      font-weight: 600;
      margin-bottom: 12px;
      color: #0e766e;
    }
    
    .form-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 12px;
    }
    
    .form-group {
      flex: 1;
      min-width: 120px;
    }
    
    .form-group label {
      display: block;
      font-size: 13px;
      margin-bottom: 5px;
      font-weight: 500;
    }
    
    .form-group input,
    .form-group select {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 14px;
    }
    
    .btn {
      display: inline-block;
      background-color: #0e766e;
      color: white;
      border: none;
      border-radius: 5px;
      padding: 8px 16px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    .btn:hover {
      background-color: #0c6259;
    }
    
    .btn-red {
      background-color: #e53e3e;
    }
    
    .btn-red:hover {
      background-color: #c53030;
    }
    
    .btn-full {
      width: 100%;
    }

    .btn-sm {
      padding: 4px 8px;
      font-size: 12px;
    }
    
    .shifts-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 16px;
      font-size: 14px;
    }
    
    .shifts-table th,
    .shifts-table td {
      border: 1px solid #e2e8f0;
      padding: 10px;
      text-align: left;
    }
    
    .shifts-table th {
      background-color: #f7fafc;
      font-weight: 600;
    }
    
    .shifts-table tr:nth-child(even) {
      background-color: #f7fafc;
    }
    
    .text-center {
      text-align: center;
    }
    
    .no-shifts {
      text-align: center;
      padding: 20px;
      color: #718096;
      font-style: italic;
    }
    
    .action-column {
      width: 80px;
      text-align: center;
    }
    
    .clear-all {
      color: #e53e3e;
      text-decoration: underline;
      background: none;
      border: none;
      font-size: 14px;
      cursor: pointer;
      margin-top: 10px;
    }
    
    .clear-all:hover {
      color: #c53030;
    }
    
    .break-container {
      display: flex;
      align-items: center;
    }
    
    .break-checkbox {
      margin-right: 10px;
      width: auto;
    }
    
    .import-preview {
      margin-top: 16px;
      background-color: #f0f9ff;
      border-radius: 8px;
      padding: 16px;
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #e2e8f0;
    }
    
    .preview-item {
      padding: 8px;
      border-bottom: 1px solid #e2e8f0;
      display: flex;
      align-items: center;
    }
    
    .preview-item:last-child {
      border-bottom: none;
    }
    
    .preview-checkbox {
      margin-right: 10px;
    }
    
    .success-message {
      background-color: #d1fae5;
      color: #065f46;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 16px;
      text-align: center;
    }
    
    .error-message {
      background-color: #fee2e2;
      color: #b91c1c;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 16px;
      text-align: center;
    }
    
    .step {
      margin-bottom: 16px;
    }
    
    .step-number {
      display: inline-block;
      width: 24px;
      height: 24px;
      background-color: #0e766e;
      color: white;
      border-radius: 50%;
      text-align: center;
      line-height: 24px;
      margin-right: 8px;
    }
    
    .instruction {
      margin-left: 32px;
      margin-bottom: 8px;
    }
    
    .code {
      font-family: monospace;
      background-color: #f7fafc;
      padding: 2px 4px;
      border-radius: 2px;
    }
    
    .file-input-container {
      margin-top: 16px;
    }
    
    .file-input-label {
      display: block;
      background-color: #f7fafc;
      border: 1px dashed #d1d5db;
      border-radius: 4px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      margin-bottom: 16px;
    }
    
    .file-input-label:hover {
      background-color: #edf2f7;
    }
    
    .file-input {
      display: none;
    }
    
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid rgba(0, 0, 0, 0.1);
      border-top-color: #0e766e;
      border-radius: 50%;
      animation: spin 1s infinite linear;
      margin-right: 10px;
      vertical-align: middle;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .url-input {
      width: 100%;
      padding: 10px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 14px;
      margin-bottom: 10px;
    }
    
    .or-divider {
      display: flex;
      align-items: center;
      margin: 20px 0;
      color: #718096;
    }
    
    .or-divider::before,
    .or-divider::after {
      content: '';
      flex: 1;
      border-bottom: 1px solid #e2e8f0;
    }
    
    .or-divider span {
      padding: 0 10px;
    }
    
    /* Overtime specific styles */
    .overtime-container {
      border-top: 1px dashed #d1d5db;
      padding-top: 12px;
      margin-top: 8px;
    }
    
    .overtime-title {
      font-weight: 500;
      margin-bottom: 8px;
      color: #0e766e;
    }
    
    .overtime-badge {
      display: inline-block;
      background-color: #feb2b2;
      color: #9b2c2c;
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 4px;
      margin-left: 4px;
    }

    .overtime-hours {
      width: 70px !important;
      text-align: center;
    }

    .overtime-position-select {
      width: 100%;
    }

    .overtime-info {
      color: #718096;
      font-size: 13px;
      margin-top: 8px;
      font-style: italic;
    }
    
    /* Shift breakdown modal */
    .modal {
      display: none;
      position: fixed;
      z-index: 100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.4);
    }
    
    .modal-content {
      background-color: #fefefe;
      margin: 10% auto;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      width: 80%;
      max-width: 700px;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #e2e8f0;
    }
    
    .modal-title {
      font-size: 20px;
      font-weight: 600;
      color: #0e766e;
    }
    
    .close-modal {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    
    .close-modal:hover,
    .close-modal:focus {
      color: black;
      text-decoration: none;
      cursor: pointer;
    }
    
    .breakdown-section {
      margin-bottom: 15px;
    }
    
    .breakdown-title {
      font-weight: 600;
      margin-bottom: 8px;
      color: #2d3748;
    }
    
    .breakdown-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
      margin-bottom: 15px;
    }
    
    .breakdown-table th,
    .breakdown-table td {
      border: 1px solid #e2e8f0;
      padding: 8px;
    }
    
    .breakdown-table th {
      background-color: #f7fafc;
      text-align: left;
    }
    
    .breakdown-summary {
      background-color: #f7fafc;
      border-radius: 6px;
      padding: 10px;
      margin-top: 15px;
    }
    
    .breakdown-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
    }
    
    .breakdown-total {
      font-weight: 600;
      border-top: 1px solid #e2e8f0;
      padding-top: 5px;
      margin-top: 5px;
    }
    
    .overtime-row {
      background-color: #fff5f5;
    }
    
    .expanded-row {
      display: none;
      background-color: #f7fafc;
    }
    
    .expanded-content {
      padding: 10px 10px 10px 30px;
    }
    
    .expand-toggle {
      cursor: pointer;
      user-select: none;
    }
    
    .shift-details-btn {
      padding: 4px 8px;
      font-size: 12px;
      background-color: #4299e1;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .shift-details-btn:hover {
      background-color: #3182ce;
    }
    
    @media (max-width: 600px) {
      .form-group {
        min-width: 100%;
      }
      
      .tab {
        padding: 10px;
      }
      
      .modal-content {
        width: 95%;
        margin: 5% auto;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Monthly Earnings Calculator</h1>
    
    <div class="total-section">
      <div class="info-text">Total monthly earnings:</div>
      <div class="total-amount" id="totalAmount">0.00 kr</div>
      <div class="info-text">Base hourly rate: 284.49 kr</div>
      <div class="info-text" id="totalHours">Total hours: 0</div>
      <div class="info-text" id="overtimeHours">Overtime hours: 0</div>
    </div>
    
    <div class="tab-container">
      <div class="tab active" data-tab="manual">Manual Entry</div>
      <div class="tab" data-tab="calendar">Import Calendar</div>
    </div>
    
    <div class="tab-content active" id="manual-tab">
      <div class="shift-form">
        <div class="form-title">Add Work Shift</div>
        
        <div class="form-row">
          <div class="form-group">
            <label for="shiftDate">Date:</label>
            <input type="date" id="shiftDate" required>
          </div>
          
          <div class="form-group">
            <label for="shiftType">Day Type:</label>
            <select id="shiftType">
              <option value="auto">Auto-detect from date</option>
              <option value="weekday">Mon-Thu</option>
              <option value="friday">Friday</option>
              <option value="saturday">Saturday</option>
              <option value="sunday">Sunday</option>
              <option value="holiday">Holiday</option>
            </select>
          </div>
        </div>
        
        <div class="form-row">
          <div class="form-group">
            <label for="startTime">Start Time:</label>
            <input type="time" id="startTime" value="09:00" required>
          </div>
          
          <div class="form-group">
            <label for="endTime">End Time:</label>
            <input type="time" id="endTime" value="17:00" required>
          </div>
        </div>
        
        <div class="form-row">
          <div class="form-group">
            <label for="breakCheck">Include 30-min meal break?</label>
            <div class="break-container">
              <input type="checkbox" id="breakCheck" class="break-checkbox">
              <input type="time" id="breakTime" value="12:00">
            </div>
          </div>
        </div>
        
        <!-- Integrated Overtime section -->
        <div class="overtime-container">
          <div class="overtime-title">Overtime Hours (100% extra pay)</div>
          <div class="form-row">
            <div class="form-group" style="max-width: 120px;">
              <label for="overtimeCheck">Include overtime?</label>
              <input type="checkbox" id="overtimeCheck" style="width: auto;">
            </div>
            
            <div class="form-group" style="max-width: 180px;">
              <label for="overtimeHours">Hours of overtime:</label>
              <input type="number" id="overtimeHours" style="width: 70px; text-align: center;" 
                     value="2" min="0" max="24" step="0.5">
            </div>
            
            <div class="form-group">
              <label for="overtimePosition">Position in shift:</label>
              <select id="overtimePosition" class="overtime-position-select">
                <option value="end">At the end of shift</option>
                <option value="start">At the beginning of shift</option>
                <option value="both">Both start and end</option>
              </select>
            </div>
          </div>
          <div class="overtime-info">
            Overtime is part of your shift with 100% extra pay (2× normal rate)
          </div>
        </div>
        
        <button class="btn btn-full" id="addShiftBtn">Add Shift</button>
      </div>
    </div>
    
    <div class="tab-content" id="calendar-tab">
      <div class="shift-form">
        <div class="form-title">Import Shifts from Calendar</div>
        
        <div class="step">
          <span class="step-number">1</span>
          <span>Enter your calendar URL:</span>
        </div>
        
        <input type="url" id="calendarUrl" class="url-input" placeholder="https://api.mypurecloud.de/api/v2/workforcemanagement/calendar/data/ics?calendarId=..." value="https://api.mypurecloud.de/api/v2/workforcemanagement/calendar/data/ics?calendarId=NJFMYKJTBcq0og7xrYPmp1YkWPBX6dhThWv2nT36254">
        
        <button class="btn btn-full" id="fetchCalendarBtn">Fetch Calendar</button>
        
        <div class="or-divider">
          <span>OR</span>
        </div>
        
        <div class="step">
          <span class="step-number">2</span>
          <span>Upload a calendar file (.ics):</span>
        </div>
        
        <div class="file-input-container">
          <label for="calendarFile" class="file-input-label">
            <span>Click to select a .ics file</span>
            <input type="file" id="calendarFile" class="file-input" accept=".ics">
          </label>
        </div>
        
        <div id="calendarMessage" style="display:none; margin-top:10px;"></div>
        
        <div id="calendarPreview" class="import-preview" style="display:none;"></div>
        
        <button class="btn btn-full" id="addCalendarShiftsBtn" style="display:none; margin-top:10px;">Add Selected Shifts</button>
      </div>
    </div>
    
    <h2>Shifts This Month</h2>
    <div id="shiftsTableContainer">
      <div class="no-shifts">No shifts added yet. Add shifts using one of the methods above.</div>
    </div>
    
    <div class="text-center">
      <button class="clear-all" id="clearAllBtn">Clear All Shifts</button>
    </div>
  </div>
  
  <!-- Shift Breakdown Modal -->
  <div id="shiftBreakdownModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Shift Breakdown</div>
        <span class="close-modal">&times;</span>
      </div>
      <div id="breakdownContent">
        <!-- Content will be dynamically inserted here -->
      </div>
    </div>
  </div>

  <script>
    (function() {
      // Constants
      const BASE_RATE = 284.49;
      
      // DOM Elements - Tabs
      const tabs = document.querySelectorAll('.tab');
      const tabContents = document.querySelectorAll('.tab-content');
      
      // DOM Elements - Manual Entry
      const totalAmountEl = document.getElementById('totalAmount');
      const totalHoursEl = document.getElementById('totalHours');
      const overtimeHoursEl = document.getElementById('overtimeHours');
      const dateInput = document.getElementById('shiftDate');
      const typeSelect = document.getElementById('shiftType');
      const startTimeInput = document.getElementById('startTime');
      const endTimeInput = document.getElementById('endTime');
      const breakCheckbox = document.getElementById('breakCheck');
      const breakTimeInput = document.getElementById('breakTime');
      const addShiftBtn = document.getElementById('addShiftBtn');
      
      // DOM Elements - Overtime
      const overtimeCheckbox = document.getElementById('overtimeCheck');
      const overtimeHoursInput = document.getElementById('overtimeHours');
      const overtimePositionSelect = document.getElementById('overtimePosition');
      
      // DOM Elements - Calendar Import
      const calendarUrlInput = document.getElementById('calendarUrl');
      const fetchCalendarBtn = document.getElementById('fetchCalendarBtn');
      const calendarFileInput = document.getElementById('calendarFile');
      const calendarMessage = document.getElementById('calendarMessage');
      const calendarPreview = document.getElementById('calendarPreview');
      const addCalendarShiftsBtn = document.getElementById('addCalendarShiftsBtn');
      
      // DOM Elements - Other
      const clearAllBtn = document.getElementById('clearAllBtn');
      const tableContainer = document.getElementById('shiftsTableContainer');
      
      // DOM Elements - Modal
      const modal = document.getElementById('shiftBreakdownModal');
      const closeModal = document.querySelector('.close-modal');
      const breakdownContent = document.getElementById('breakdownContent');
      
      // Set today's date as default
      dateInput.value = new Date().toISOString().split('T')[0];
      
      // Store shifts and parsed shifts
      let shifts = [];
      let parsedCalendarShifts = [];
      
      // Close the modal when clicking the × button
      closeModal.onclick = function() {
        modal.style.display = "none";
      };
      
      // Close the modal when clicking outside it
      window.onclick = function(event) {
        if (event.target == modal) {
          modal.style.display = "none";
        }
      };
      
      // Calculate overtime earnings for a shift
      function calculateOvertimeEarnings(shift) {
        if (!shift.includeOvertime || !shift.overtimeDuration || shift.overtimeDuration <= 0) {
          return 0;
        }
        
        let overtimeEarnings = 0;
        
        // Check if segments exist
        if (!shift.segments || !Array.isArray(shift.segments)) {
          return 0;
        }
        
        // For each segment, add up all overtime earnings
        shift.segments.forEach(segment => {
          if (segment.isOvertime) {
            // Full segment is overtime
            overtimeEarnings += segment.earnings;
          } else if (segment.isPartialOvertime && segment.overtimeHours > 0) {
            // Calculate the overtime portion's earnings manually to avoid NaN
            const segmentRate = segment.rate || 1.0;
            overtimeEarnings += segment.overtimeHours * BASE_RATE * segmentRate * 2;
          }
        });
        
        return overtimeEarnings;
      }
      
      // Show shift breakdown in modal
      function showShiftBreakdown(shiftId) {
        const shift = shifts.find(s => s.id === shiftId);
        
        if (!shift) return;
        
        // Format date
        const dateStr = formatDate(shift.date);
        const dayName = shift.dayType.charAt(0).toUpperCase() + shift.dayType.slice(1);
        
        // Calculate regular and overtime parts
        const regularHours = shift.duration - (shift.overtimeDuration || 0);
        const overtimeEarnings = calculateOvertimeEarnings(shift);
        const regularEarnings = shift.earnings - overtimeEarnings;
        
        // Create content HTML
        let html = `
          <div class="breakdown-section">
            <div class="breakdown-title">${dateStr} (${dayName})</div>
            <div>Shift time: ${shift.startTime} - ${shift.endTime}</div>
            ${shift.includeBreak ? `<div>Break: ${shift.breakTime} (30 minutes)</div>` : ''}
            ${shift.includeOvertime ? `<div>Overtime: ${shift.overtimeHours} hours (${shift.overtimePosition === 'start' ? 'at start' : shift.overtimePosition === 'end' ? 'at end' : 'at start and end'})</div>` : ''}
          </div>
          
          <div class="breakdown-section">
            <div class="breakdown-title">Time Segments</div>
            <table class="breakdown-table">
              <thead>
                <tr>
                  <th>Time</th>
                  <th>Hours</th>
                  <th>Rate</th>
                  <th>Multiplier</th>
                  <th>Earnings</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        shift.segments.forEach(segment => {
          const isOvertime = segment.isOvertime || segment.isPartialOvertime;
          
          if (segment.isPartialOvertime) {
            // Regular part
            html += `
              <tr>
                <td>${segment.time}</td>
                <td>${segment.regularHours.toFixed(2)}</td>
                <td>${(BASE_RATE * segment.rate).toFixed(2)} kr</td>
                <td>${segment.rate.toFixed(2)}×</td>
                <td>${(segment.regularHours * BASE_RATE * segment.rate).toFixed(2)} kr</td>
              </tr>
            `;
            
            // Overtime part
            html += `
              <tr class="overtime-row">
                <td>${segment.time} (OT)</td>
                <td>${segment.overtimeHours.toFixed(2)}</td>
                <td>${(BASE_RATE * segment.rate * 2).toFixed(2)} kr</td>
                <td>${(segment.rate * 2).toFixed(2)}×</td>
                <td>${(segment.overtimeHours * BASE_RATE * segment.rate * 2).toFixed(2)} kr</td>
              </tr>
            `;
          } else {
            html += `
              <tr${isOvertime ? ' class="overtime-row"' : ''}>
                <td>${segment.time}${isOvertime ? ' (OT)' : ''}</td>
                <td>${segment.hours.toFixed(2)}</td>
                <td>${(BASE_RATE * segment.rate * (isOvertime ? 2 : 1)).toFixed(2)} kr</td>
                <td>${(segment.rate * (isOvertime ? 2 : 1)).toFixed(2)}×</td>
                <td>${segment.earnings.toFixed(2)} kr</td>
              </tr>
            `;
          }
        });
        
        html += `
              </tbody>
            </table>
          </div>
          
          <div class="breakdown-summary">
            <div class="breakdown-item">
              <span>Regular hours:</span>
              <span>${regularHours.toFixed(2)}</span>
            </div>
            <div class="breakdown-item">
              <span>Regular earnings:</span>
              <span>${regularEarnings.toFixed(2)} kr</span>
            </div>
            ${shift.overtimeDuration > 0 ? `
            <div class="breakdown-item">
              <span>Overtime hours:</span>
              <span>${shift.overtimeDuration.toFixed(2)}</span>
            </div>
            <div class="breakdown-item">
              <span>Overtime earnings:</span>
              <span>${overtimeEarnings.toFixed(2)} kr</span>
            </div>
            ` : ''}
            <div class="breakdown-item breakdown-total">
              <span>Total earnings:</span>
              <span>${shift.earnings.toFixed(2)} kr</span>
            </div>
          </div>
        `;
        
        breakdownContent.innerHTML = html;
        modal.style.display = "block";
      }
      
      // Toggle overtime options when checkbox is clicked
      overtimeCheckbox.addEventListener('change', function() {
        // Enable/disable the overtime input fields
        overtimeHoursInput.disabled = !this.checked;
        overtimePositionSelect.disabled = !this.checked;
        
        // Update the max overtime hours based on total shift duration
        if (this.checked) {
          updateMaxOvertimeHours();
        }
      });
      
      // Update max overtime hours when shift times change
      startTimeInput.addEventListener('change', updateMaxOvertimeHours);
      endTimeInput.addEventListener('change', updateMaxOvertimeHours);
      
      // Update max overtime hours based on shift duration
      function updateMaxOvertimeHours() {
        if (!overtimeCheckbox.checked) return;
        
        const startMinutes = timeToMinutes(startTimeInput.value);
        let endMinutes = timeToMinutes(endTimeInput.value);
        
        // Handle overnight shifts
        if (endMinutes < startMinutes) {
          endMinutes += 24 * 60;
        }
        
        // Calculate total shift hours
        const totalHours = (endMinutes - startMinutes) / 60;
        
        // Set max overtime hours to total shift hours
        overtimeHoursInput.max = totalHours;
        
        // If current value is more than max, adjust it
        if (parseFloat(overtimeHoursInput.value) > totalHours) {
          overtimeHoursInput.value = totalHours;
        }
      }
      
      // Tab switching
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          // Remove active class from all tabs and contents
          tabs.forEach(t => t.classList.remove('active'));
          tabContents.forEach(c => c.classList.remove('active'));
          
          // Add active class to clicked tab and corresponding content
          tab.classList.add('active');
          document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
        });
      });
      
      // Load shifts from localStorage if available
      if (localStorage.getItem('monthlyShifts')) {
        try {
          const savedShifts = JSON.parse(localStorage.getItem('monthlyShifts'));
          if (Array.isArray(savedShifts)) {
            shifts = savedShifts.map(shift => ({
              ...shift,
              date: new Date(shift.date)
            }));
            updateShiftsTable();
            updateTotals();
          }
        } catch (e) {
          console.error("Error loading saved shifts:", e);
        }
      }
      
      // Compensation rates based on day type and time
      const compensationRates = {
        'weekday': [
          { range: '06:00-08:00', rate: 1.25 },
          { range: '08:00-16:00', rate: 1.00 },
          { range: '16:00-18:00', rate: 1.25 },
          { range: '18:00-21:00', rate: 1.30 },
          { range: '21:00-06:00', rate: 2.00 },
          { range: 'default', rate: 1.00 }
        ],
        'friday': [
          { range: '06:00-08:00', rate: 1.25 },
          { range: '08:00-16:00', rate: 1.00 },
          { range: '16:00-21:00', rate: 1.50 },
          { range: '21:00-06:00', rate: 2.00 },
          { range: 'default', rate: 1.00 }
        ],
        'saturday': [
          { range: '00:00-06:00', rate: 2.00 },
          { range: '06:00-15:30', rate: 2.00 },
          { range: '15:30-24:00', rate: 2.20 },
          { range: 'default', rate: 2.00 }
        ],
        'sunday': [
          { range: '00:00-24:00', rate: 2.20 },
          { range: 'default', rate: 2.20 }
        ],
        'holiday': [
          { range: '00:00-24:00', rate: 2.50 },
          { range: 'default', rate: 2.50 }
        ]
      };
      
      // Norwegian holidays (simplified)
      const holidays = [
        { month: 0, day: 1 },    // Jan 1 - New Year
        { month: 4, day: 1 },    // May 1 - Labor Day
        { month: 4, day: 17 },   // May 17 - Constitution Day
        { month: 11, day: 25 },  // Dec 25 - Christmas
        { month: 11, day: 26 }   // Dec 26 - Boxing Day
      ];
      
      // Helper: Check if date is a holiday
      function isHoliday(date) {
        const month = date.getMonth();
        const day = date.getDate();
        
        return holidays.some(h => h.month === month && h.day === day);
      }
      
      // Helper: Determine day type from date
      function getDayTypeFromDate(date) {
        if (isHoliday(date)) return 'holiday';
        
        const day = date.getDay();
        if (day === 0) return 'sunday';
        if (day === 6) return 'saturday';
        if (day === 5) return 'friday';
        return 'weekday';
      }
      
      // Helper: Convert time string to minutes
      function timeToMinutes(timeStr) {
        const [hours, minutes] = timeStr.split(':').map(Number);
        return hours * 60 + minutes;
      }
      
      // Helper: Convert minutes to time string
      function minutesToTime(minutes) {
        const hours = Math.floor(minutes / 60) % 24;
        const mins = minutes % 60;
        return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
      }
      
      // Helper: Check if time is in range
      function isTimeInRange(time, start, end) {
        const timeMin = timeToMinutes(time);
        const startMin = timeToMinutes(start);
        let endMin = timeToMinutes(end);
        
        // Handle overnight ranges
        if (endMin < startMin) {
          endMin += 24 * 60;
          
          const timeHours = parseInt(time.split(':')[0]);
          let adjustedTimeMin = timeMin;
          
          if (timeHours < 12 && startMin > 12 * 60) {
            adjustedTimeMin += 24 * 60;
          }
          
          return adjustedTimeMin >= startMin || timeMin <= endMin;
        }
        
        return timeMin >= startMin && timeMin <= endMin;
      }
      
      // Format date for display
      function formatDate(date) {
        return date.toLocaleDateString(undefined, {
          weekday: 'short',
          month: 'short',
          day: 'numeric'
        });
      }
      
      // Calculate earnings for a shift with integrated overtime
      function calculateShiftEarnings(date, dayType, startTime, endTime, includeBreak, breakTime, includeOvertime, overtimeHours, overtimePosition) {
        // Calculate duration
        let startMinutes = timeToMinutes(startTime);
        let endMinutes = timeToMinutes(endTime);
        
        // Handle overnight shifts
        if (endMinutes < startMinutes) {
          endMinutes += 24 * 60;
        }
        
        const totalShiftMinutes = endMinutes - startMinutes;
        const totalShiftHours = totalShiftMinutes / 60;
        
        // Get rates for this day type
        const rates = compensationRates[dayType];
        
        // Track segments and overtime info
        let segments = [];
        let totalDuration = 0;
        let totalEarnings = 0;
        let overtimeDuration = 0;
        
        // Calculate overtime minutes if applicable
        let overtimeStartMinutes = null;
        let overtimeEndMinutes = null;
        
        if (includeOvertime && overtimeHours > 0) {
          const overtimeMinutes = overtimeHours * 60;
          
          // Determine overtime start/end based on position selection
          switch (overtimePosition) {
            case 'start':
              overtimeStartMinutes = startMinutes;
              overtimeEndMinutes = startMinutes + overtimeMinutes;
              break;
              
            case 'end':
              overtimeStartMinutes = endMinutes - overtimeMinutes;
              overtimeEndMinutes = endMinutes;
              break;
              
            case 'both':
              // Split overtime between start and end
              const halfOvertimeMinutes = overtimeMinutes / 2;
              
              // First part overtime (at start)
              const firstOvertimeStart = startMinutes;
              const firstOvertimeEnd = startMinutes + halfOvertimeMinutes;
              
              // Second part overtime (at end)
              const secondOvertimeStart = endMinutes - halfOvertimeMinutes;
              const secondOvertimeEnd = endMinutes;
              
              // We'll handle this special case within the calculation by passing
              // both start and end segments explicitly
              
              // For now, just set these for the proper duration calculation
              overtimeStartMinutes = firstOvertimeStart;
              overtimeEndMinutes = firstOvertimeEnd;
              break;
          }
        }
        
        // Handle meal break
        if (includeBreak && breakTime) {
          // Get break time in minutes
          let breakStartMinutes = timeToMinutes(breakTime);
          
          // For overnight shifts, adjust break time if needed
          if (startMinutes > endMinutes && breakStartMinutes < startMinutes) {
            breakStartMinutes += 24 * 60;
          }
          
          // Make sure break is within shift hours
          if (breakStartMinutes >= startMinutes && breakStartMinutes + 30 <= endMinutes) {
            // Break is within shift time
            // We'll calculate earnings in two parts: before break and after break
            
            const breakEndMinutes = breakStartMinutes + 30; // 30 minute break
            
            // Special handling for "both" overtime position
            if (includeOvertime && overtimeHours > 0 && overtimePosition === 'both') {
              const overtimeMinutes = overtimeHours * 60;
              const halfOvertimeMinutes = overtimeMinutes / 2;
              
              // First part overtime (at start)
              const firstOvertimeStart = startMinutes;
              const firstOvertimeEnd = startMinutes + halfOvertimeMinutes;
              
              // Second part overtime (at end)
              const secondOvertimeStart = endMinutes - halfOvertimeMinutes;
              const secondOvertimeEnd = endMinutes;
              
              // Calculate first part (start to break)
              const firstPartResult = calculatePartialShiftEarnings(
                dayType, 
                rates,
                startMinutes, 
                breakStartMinutes,
                firstOvertimeStart,
                firstOvertimeEnd
              );
              
              // Calculate second part (after break to end)
              const secondPartResult = calculatePartialShiftEarnings(
                dayType,
                rates,
                breakEndMinutes,
                endMinutes,
                secondOvertimeStart,
                secondOvertimeEnd
              );
              
              // Combine results
              totalDuration = firstPartResult.duration + secondPartResult.duration;
              totalEarnings = firstPartResult.earnings + secondPartResult.earnings;
              segments = [...firstPartResult.segments, ...secondPartResult.segments];
              overtimeDuration = firstPartResult.overtimeDuration + secondPartResult.overtimeDuration;
            } else {
              // Calculate first part (start to break)
              const firstPartResult = calculatePartialShiftEarnings(
                dayType, 
                rates,
                startMinutes, 
                breakStartMinutes,
                overtimePosition === 'start' ? overtimeStartMinutes : null,
                overtimePosition === 'start' ? overtimeEndMinutes : null
              );
              
              // Calculate second part (after break to end)
              const secondPartResult = calculatePartialShiftEarnings(
                dayType,
                rates,
                breakEndMinutes,
                endMinutes,
                overtimePosition === 'end' ? overtimeStartMinutes : null,
                overtimePosition === 'end' ? overtimeEndMinutes : null
              );
              
              // Combine results
              totalDuration = firstPartResult.duration + secondPartResult.duration;
              totalEarnings = firstPartResult.earnings + secondPartResult.earnings;
              segments = [...firstPartResult.segments, ...secondPartResult.segments];
              overtimeDuration = firstPartResult.overtimeDuration + secondPartResult.overtimeDuration;
            }
          } else {
            // Break is outside shift hours - just calculate normally
            const result = calculatePartialShiftEarnings(
              dayType, 
              rates, 
              startMinutes, 
              endMinutes,
              overtimeStartMinutes,
              overtimeEndMinutes
            );
            
            totalDuration = result.duration;
            totalEarnings = result.earnings;
            segments = result.segments;
            overtimeDuration = result.overtimeDuration;
          }
        } else {
          // No break - calculate normally
          if (includeOvertime && overtimeHours > 0 && overtimePosition === 'both') {
            const overtimeMinutes = overtimeHours * 60;
            const halfOvertimeMinutes = overtimeMinutes / 2;
            
            // First part overtime (at start)
            const firstOvertimeStart = startMinutes;
            const firstOvertimeEnd = startMinutes + halfOvertimeMinutes;
            
            // Second part overtime (at end)
            const secondOvertimeStart = endMinutes - halfOvertimeMinutes;
            const secondOvertimeEnd = endMinutes;
            
            // Calculate first part (with overtime at start)
            const firstPartResult = calculatePartialShiftEarnings(
              dayType, 
              rates,
              startMinutes, 
              Math.min(endMinutes, startMinutes + totalShiftMinutes/2),
              firstOvertimeStart,
              firstOvertimeEnd
            );
            
            // Calculate second part (with overtime at end)
            const secondPartResult = calculatePartialShiftEarnings(
              dayType,
              rates,
              Math.max(startMinutes, endMinutes - totalShiftMinutes/2),
              endMinutes,
              secondOvertimeStart,
              secondOvertimeEnd
            );
            
            // Combine results
            totalDuration = firstPartResult.duration + secondPartResult.duration;
            totalEarnings = firstPartResult.earnings + secondPartResult.earnings;
            segments = [...firstPartResult.segments, ...secondPartResult.segments];
            overtimeDuration = firstPartResult.overtimeDuration + secondPartResult.overtimeDuration;
          } else {
            // Regular calculation with overtime at start or end
            const result = calculatePartialShiftEarnings(
              dayType, 
              rates, 
              startMinutes, 
              endMinutes,
              overtimeStartMinutes,
              overtimeEndMinutes
            );
            
            totalDuration = result.duration;
            totalEarnings = result.earnings;
            segments = result.segments;
            overtimeDuration = result.overtimeDuration;
          }
        }
        
        return {
          duration: totalDuration,
          earnings: totalEarnings,
          segments: segments,
          overtimeDuration: overtimeDuration
        };
      }
      
      // Calculate earnings for part of a shift
      function calculatePartialShiftEarnings(dayType, rates, startMinutes, endMinutes, overtimeStartMinutes, overtimeEndMinutes) {
        const durationHours = (endMinutes - startMinutes) / 60;
        
        // Track total earnings and segments
        let totalEarnings = 0;
        let segments = [];
        let currentMinutes = startMinutes;
        let hoursRemaining = durationHours;
        let overtimeDuration = 0;
        
        while (hoursRemaining > 0) {
          // Format current time
          const currentHour = Math.floor((currentMinutes % (24 * 60)) / 60);
          const currentMin = currentMinutes % 60;
          const currentTime = `${currentHour.toString().padStart(2, '0')}:${currentMin.toString().padStart(2, '0')}`;
          
          // Find applicable rate
          let rate = 1.0;
          let rateDesc = 'Regular';
          
          for (const period of rates) {
            if (period.range === 'default') continue;
            
            const [start, end] = period.range.split('-');
            
            if (isTimeInRange(currentTime, start, end)) {
              rate = period.rate;
              rateDesc = period.range;
              break;
            }
          }
          
          // Determine segment duration
          let hoursInSegment = 0;
          
          // Fixed rate for entire day
          if (rates.length === 2 && rates[0].range === '00:00-24:00') {
            hoursInSegment = hoursRemaining;
          } else {
            // Find next rate change
            let nextChangeMinutes = 24 * 60;
            
            for (const period of rates) {
              if (period.range === 'default') continue;
              
              const [start, _] = period.range.split('-');
              const startMin = timeToMinutes(start);
              
              // Next rate change after current time
              if ((startMin > currentMinutes % (24 * 60)) && 
                  (startMin < nextChangeMinutes)) {
                nextChangeMinutes = startMin;
              }
            }
            
            // If no next change found in the day, go to midnight
            if (nextChangeMinutes === 24 * 60) {
              nextChangeMinutes = 24 * 60;
            }
            
            // Calculate hours until change
            const minutesUntilChange = 
              nextChangeMinutes > (currentMinutes % (24 * 60)) 
                ? nextChangeMinutes - (currentMinutes % (24 * 60))
                : (24 * 60 + nextChangeMinutes) - (currentMinutes % (24 * 60));
            
            const hoursUntilChange = minutesUntilChange / 60;
            
            // Use smaller of hours until change, remaining hours, or time to end
            const hoursToEnd = (endMinutes - currentMinutes) / 60;
            hoursInSegment = Math.min(hoursUntilChange, hoursRemaining, hoursToEnd);
          }
          
          // Check if this segment overlaps with overtime
          let isOvertime = false;
          let overtimeHoursInSegment = 0;
          
          if (overtimeStartMinutes !== null && overtimeEndMinutes !== null) {
            // Check for overlap between this segment and overtime period
            const segmentEndMinutes = currentMinutes + (hoursInSegment * 60);
            
            // If segment overlaps with overtime
            if (!(segmentEndMinutes <= overtimeStartMinutes || currentMinutes >= overtimeEndMinutes)) {
              // Calculate overlap
              const overlapStart = Math.max(currentMinutes, overtimeStartMinutes);
              const overlapEnd = Math.min(segmentEndMinutes, overtimeEndMinutes);
              const overlapHours = (overlapEnd - overlapStart) / 60;
              
              isOvertime = true;
              overtimeHoursInSegment = overlapHours;
              overtimeDuration += overlapHours;
              
              // If partial overlap, we split this segment
              if (overlapHours < hoursInSegment) {
                // We'll handle this as two separate segments
                const regularHours = hoursInSegment - overlapHours;
                
                // First, calculate earnings for regular (non-overtime) part
                const regularEarnings = regularHours * BASE_RATE * rate;
                totalEarnings += regularEarnings;
                
                // Then calculate earnings for overtime part (with 100% extra)
                const overtimeEarnings = overlapHours * BASE_RATE * rate * 2;
                totalEarnings += overtimeEarnings;
                
                // Add segment with both parts
                segments.push({
                  time: currentTime,
                  hours: hoursInSegment,
                  rate: rate,
                  earnings: regularEarnings + overtimeEarnings,
                  regularHours: regularHours,
                  overtimeHours: overlapHours,
                  isPartialOvertime: true
                });
              } else {
                // Full segment is overtime
                const segmentEarnings = hoursInSegment * BASE_RATE * rate * 2; // 100% extra pay
                totalEarnings += segmentEarnings;
                
                // Save segment
                segments.push({
                  time: currentTime,
                  hours: hoursInSegment,
                  rate: rate,
                  earnings: segmentEarnings,
                  isOvertime: true
                });
              }
            } else {
              // No overlap with overtime - calculate normally
              const segmentEarnings = hoursInSegment * BASE_RATE * rate;
              totalEarnings += segmentEarnings;
              
              // Save segment
              segments.push({
                time: currentTime,
                hours: hoursInSegment,
                rate: rate,
                earnings: segmentEarnings
              });
            }
          } else {
            // No overtime - calculate normally
            const segmentEarnings = hoursInSegment * BASE_RATE * rate;
            totalEarnings += segmentEarnings;
            
            // Save segment
            segments.push({
              time: currentTime,
              hours: hoursInSegment,
              rate: rate,
              earnings: segmentEarnings
            });
          }
          
          // Advance time and reduce remaining hours
          currentMinutes += hoursInSegment * 60;
          hoursRemaining -= hoursInSegment;
        }
        
        return {
          duration: durationHours,
          earnings: totalEarnings,
          segments: segments,
          overtimeDuration: overtimeDuration
        };
      }
      
      // Add a shift manually
      function addShift() {
        const dateStr = dateInput.value;
        if (!dateStr) {
          alert('Please select a date');
          return;
        }
        
        const date = new Date(dateStr);
        let dayType = typeSelect.value;
        
        // Auto-detect day type if needed
        if (dayType === 'auto') {
          dayType = getDayTypeFromDate(date);
        }
        
        const startTime = startTimeInput.value;
        const endTime = endTimeInput.value;
        
        if (!startTime || !endTime) {
          alert('Please enter start and end times');
          return;
        }
        
        // Get break info
        const includeBreak = breakCheckbox.checked;
        const breakTime = breakTimeInput.value;
        
        // Get overtime info
        const includeOvertime = overtimeCheckbox.checked;
        const overtimeHours = includeOvertime ? parseFloat(overtimeHoursInput.value) : 0;
        const overtimePosition = overtimePositionSelect.value;
        
        // Calculate earnings
        const result = calculateShiftEarnings(
          date, 
          dayType, 
          startTime, 
          endTime, 
          includeBreak, 
          breakTime,
          includeOvertime,
          overtimeHours,
          overtimePosition
        );
        
        // Create shift object
        const shift = {
          id: Date.now(), // Unique ID
          date: date,
          dayType: dayType,
          startTime: startTime,
          endTime: endTime,
          includeBreak: includeBreak,
          breakTime: breakTime,
          includeOvertime: includeOvertime,
          overtimeHours: overtimeHours,
          overtimePosition: overtimePosition,
          duration: result.duration,
          earnings: result.earnings,
          segments: result.segments,
          overtimeDuration: result.overtimeDuration || 0
        };
        
        // Add to array
        shifts.push(shift);
        
        // Save to localStorage
        saveShifts();
        
        // Update UI
        updateShiftsTable();
        updateTotals();
        
        // Do NOT show shift breakdown immediately - this has been removed
        // showShiftBreakdown(shift.id);
      }
      
      // Fetch calendar from URL
      async function fetchCalendar() {
        const url = calendarUrlInput.value.trim();
        
        if (!url) {
          showCalendarMessage('Please enter a calendar URL.', false);
          return;
        }
        
        // Show loading state
        showCalendarMessage('<span class="loading"></span> Fetching calendar data...', true);
        calendarPreview.style.display = 'none';
        addCalendarShiftsBtn.style.display = 'none';
        
        try {
          // Try to fetch the calendar
          const response = await fetch(url, {
            method: 'GET',
            mode: 'cors',
            credentials: 'include' // Include cookies for authentication
          });
          
          if (!response.ok) {
            throw new Error(`Error fetching calendar: ${response.status} ${response.statusText}`);
          }
          
          const icsData = await response.text();
          processIcsData(icsData);
        } catch (error) {
          console.error("Error fetching calendar:", error);
          
          // Show error message and suggest file upload
          showCalendarMessage(`Could not fetch calendar data directly. This is likely due to browser security restrictions. Please download the calendar file and upload it using the file option below.`, false);
        }
      }
      
      // Handle calendar file upload
      function handleCalendarFile(event) {
        const file = event.target.files[0];
        
        if (!file) return;
        
        if (file.name.endsWith('.ics')) {
          // Show loading state
          showCalendarMessage('<span class="loading"></span> Processing calendar file...', true);
          calendarPreview.style.display = 'none';
          addCalendarShiftsBtn.style.display = 'none';
          
          const reader = new FileReader();
          
          reader.onload = function(e) {
            const icsData = e.target.result;
            processIcsData(icsData);
          };
          
          reader.onerror = function() {
            showCalendarMessage('Error reading file. Please try again.', false);
          };
          
          reader.readAsText(file);
        } else {
          showCalendarMessage('Please select a valid .ics calendar file.', false);
        }
      }
      
      // Process ICS data
      function processIcsData(icsData) {
        try {
          // Parse the ICS data
          const events = parseIcsEvents(icsData);
          
          if (events.length === 0) {
            showCalendarMessage('No work shifts found in the calendar.', false);
            return;
          }
          
          // Extract work shifts
          parsedCalendarShifts = extractWorkShifts(events);
          
          if (parsedCalendarShifts.length === 0) {
            showCalendarMessage('No work shifts found in the calendar.', false);
            return;
          }
          
          // Show success message
          showCalendarMessage(`Found ${parsedCalendarShifts.length} work shifts in your calendar!`, true);
          
          // Show preview
          showCalendarPreview(parsedCalendarShifts);
          
          // Show add button
          addCalendarShiftsBtn.style.display = 'block';
        } catch (error) {
          console.error("Error processing calendar data:", error);
          showCalendarMessage('Error processing calendar data. Please check the file format.', false);
        }
      }
      
      // Parse ICS events
      function parseIcsEvents(icsData) {
        const events = [];
        const lines = icsData.split(/\r\n|\n|\r/);
        
        let currentEvent = null;
        let inEvent = false;
        
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          
          if (line.startsWith('BEGIN:VEVENT')) {
            inEvent = true;
            currentEvent = {};
          } else if (line.startsWith('END:VEVENT')) {
            inEvent = false;
            if (currentEvent) {
              events.push(currentEvent);
            }
            currentEvent = null;
          } else if (inEvent && currentEvent) {
            // Handle line continuation
            if (line.startsWith(' ') || line.startsWith('\t')) {
              // This is a continuation of the previous line
              // Find the last property and append this line to its value
              const lastProperty = Object.keys(currentEvent).pop();
              if (lastProperty) {
                currentEvent[lastProperty] += line.substring(1); // Remove the leading space
              }
              continue;
            }
            
            // Regular line - parse property
            const colonIndex = line.indexOf(':');
            if (colonIndex > 0) {
              const key = line.substring(0, colonIndex);
              const value = line.substring(colonIndex + 1);
              
              // Handle semicolon parameters in key
              const keyParts = key.split(';');
              const propertyName = keyParts[0];
              
              currentEvent[propertyName] = value;
            }
          }
        }
        
        return events;
      }
      
      // Extract work shifts from calendar events
      function extractWorkShifts(events) {
        return events
          .filter(event => {
            // Filter for work shifts - usually has a SUMMARY containing work-related keywords
            return event.SUMMARY && (
              event.SUMMARY.includes('Work') ||
              event.SUMMARY.includes('Shift') ||
              event.SUMMARY.includes('HB') ||
              event.SUMMARY.includes('GST') ||
              event.SUMMARY.includes('Telefon') ||
              event.SUMMARY.includes('Deltid')
            );
          })
          .map(event => {
            // Parse start and end times
            const startDate = parseIcsDate(event.DTSTART);
            const endDate = parseIcsDate(event.DTEND);
            
            if (!startDate || !endDate) return null;
            
            // Format times (HH:MM)
            const startTime = `${startDate.getHours().toString().padStart(2, '0')}:${startDate.getMinutes().toString().padStart(2, '0')}`;
            const endTime = `${endDate.getHours().toString().padStart(2, '0')}:${endDate.getMinutes().toString().padStart(2, '0')}`;
            
            // Determine day type
            const dayType = getDayTypeFromDate(startDate);
            
            // Determine if this shift likely includes a break
            // Shifts longer than 5 hours typically include a break
            const durationHours = (endDate - startDate) / (1000 * 60 * 60);
            const includeBreak = durationHours >= 5;
            
            // Default break time is halfway through the shift
            const breakTimeDate = new Date(startDate.getTime() + (endDate - startDate) / 2);
            const breakTime = `${breakTimeDate.getHours().toString().padStart(2, '0')}:${breakTimeDate.getMinutes().toString().padStart(2, '0')}`;
            
            return {
              date: startDate,
              dayType: dayType,
              startTime: startTime,
              endTime: endTime,
              includeBreak: includeBreak,
              breakTime: breakTime,
              includeOvertime: false, // Default to no overtime for imported shifts
              overtimeHours: 0,
              overtimePosition: 'end',
              summary: event.SUMMARY || 'Work Shift',
              description: event.DESCRIPTION || ''
            };
          })
          .filter(Boolean);
      }
      
      // Parse ICS date format
      function parseIcsDate(dateStr) {
        if (!dateStr) return null;
        
        let year, month, day, hour, minute, second;
        
        // Handle dates with timezone info
        if (dateStr.includes('T')) {
          // Format: YYYYMMDDTHHMMSSZ or similar
          const dateTimeStr = dateStr.split(':')[1] || dateStr;
          const basicFormat = dateTimeStr.replace(/[^0-9T]/g, '');
          
          if (basicFormat.length >= 15) { // YYYYMMDDTHHMMSS
            year = parseInt(basicFormat.substring(0, 4));
            month = parseInt(basicFormat.substring(4, 6)) - 1; // 0-indexed months
            day = parseInt(basicFormat.substring(6, 8));
            hour = parseInt(basicFormat.substring(9, 11));
            minute = parseInt(basicFormat.substring(11, 13));
            second = parseInt(basicFormat.substring(13, 15));
            
            return new Date(year, month, day, hour, minute, second);
          }
        } else {
          // Format: YYYYMMDD
          const basicFormat = dateStr.replace(/[^0-9]/g, '');
          
          if (basicFormat.length >= 8) { // YYYYMMDD
            year = parseInt(basicFormat.substring(0, 4));
            month = parseInt(basicFormat.substring(4, 6)) - 1; // 0-indexed months
            day = parseInt(basicFormat.substring(6, 8));
            
            return new Date(year, month, day, 0, 0, 0);
          }
        }
        
        return null;
      }
      
      // Show calendar import message
      function showCalendarMessage(message, isSuccess) {
        calendarMessage.innerHTML = message;
        calendarMessage.className = isSuccess ? 'success-message' : 'error-message';
        calendarMessage.style.display = 'block';
      }
      
      // Show calendar preview
      function showCalendarPreview(shifts) {
        calendarPreview.innerHTML = '';
        calendarPreview.style.display = 'block';
        
        // Group shifts by month
        const shiftsByMonth = {};
        
        shifts.forEach((shift, index) => {
          const monthKey = `${shift.date.getFullYear()}-${shift.date.getMonth()}`;
          if (!shiftsByMonth[monthKey]) {
            shiftsByMonth[monthKey] = [];
          }
          shiftsByMonth[monthKey].push({ ...shift, index });
        });
        
        // Sort months chronologically
        const sortedMonths = Object.keys(shiftsByMonth).sort();
        
        // Create preview for each month
        sortedMonths.forEach(monthKey => {
          const monthShifts = shiftsByMonth[monthKey];
          const [year, month] = monthKey.split('-').map(Number);
          
          // Create month header
          const monthHeader = document.createElement('div');
          monthHeader.style.fontWeight = 'bold';
          monthHeader.style.marginTop = '10px';
          monthHeader.style.marginBottom = '5px';
          monthHeader.textContent = new Date(year, month, 1).toLocaleDateString(undefined, { year: 'numeric', month: 'long' });
          
          calendarPreview.appendChild(monthHeader);
          
          // Create shift items for this month
          monthShifts.forEach(shift => {
            const previewItem = document.createElement('div');
            previewItem.className = 'preview-item';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'preview-checkbox';
            checkbox.value = shift.index;
            checkbox.checked = true;
            
            const label = document.createElement('div');
            
            // Format the date and time range
            const dateStr = formatDate(shift.date);
            const timeRange = `${shift.startTime}-${shift.endTime}`;
            
            // Format duration
            const durationHours = (timeToMinutes(shift.endTime) - timeToMinutes(shift.startTime)) / 60;
            const durationStr = `${durationHours.toFixed(1)}h`;
            
            label.textContent = `${dateStr}: ${timeRange} (${durationStr}) ${shift.summary}`;
            
            previewItem.appendChild(checkbox);
            previewItem.appendChild(label);
            calendarPreview.appendChild(previewItem);
          });
        });
      }
      
      // Add calendar shifts
      function addCalendarShifts() {
        // Get selected shifts
        const selectedCheckboxes = calendarPreview.querySelectorAll('input[type=checkbox]:checked');
        
        if (selectedCheckboxes.length === 0) {
          showCalendarMessage('Please select at least one shift to add.', false);
          return;
        }
        
        // Process each selected shift
        const addedShifts = [];
        
        selectedCheckboxes.forEach(checkbox => {
          const index = parseInt(checkbox.value);
          const parsedShift = parsedCalendarShifts[index];
          
          // Calculate earnings
          const result = calculateShiftEarnings(
            parsedShift.date,
            parsedShift.dayType,
            parsedShift.startTime,
            parsedShift.endTime,
            parsedShift.includeBreak,
            parsedShift.breakTime,
            parsedShift.includeOvertime,
            parsedShift.overtimeHours,
            parsedShift.overtimePosition
          );
          
          // Create shift object
          const shift = {
            id: Date.now() + index, // Unique ID
            date: parsedShift.date,
            dayType: parsedShift.dayType,
            startTime: parsedShift.startTime,
            endTime: parsedShift.endTime,
            includeBreak: parsedShift.includeBreak,
            breakTime: parsedShift.breakTime,
            includeOvertime: parsedShift.includeOvertime,
            overtimeHours: parsedShift.overtimeHours,
            overtimePosition: parsedShift.overtimePosition,
            duration: result.duration,
            earnings: result.earnings,
            segments: result.segments,
            overtimeDuration: result.overtimeDuration,
            summary: parsedShift.summary
          };
          
          // Add to array
          shifts.push(shift);
          addedShifts.push(shift);
        });
        
        // Save to localStorage
        saveShifts();
        
        // Update UI
        updateShiftsTable();
        updateTotals();
        
        // Show success message
        showCalendarMessage(`Added ${addedShifts.length} shifts to your monthly total!`, true);
        
        // Clear preview
        calendarPreview.style.display = 'none';
        addCalendarShiftsBtn.style.display = 'none';
      }
      
      // Delete a shift
      function deleteShift(id) {
        shifts = shifts.filter(shift => shift.id !== id);
        saveShifts();
        updateShiftsTable();
        updateTotals();
      }
      
      // Clear all shifts
      function clearAllShifts() {
        if (confirm('Are you sure you want to clear all shifts?')) {
          shifts = [];
          saveShifts();
          updateShiftsTable();
          updateTotals();
        }
      }
      
      // Save shifts to localStorage
      function saveShifts() {
        localStorage.setItem('monthlyShifts', JSON.stringify(shifts));
      }
      
      // Update the shifts table
      function updateShiftsTable() {
        if (shifts.length === 0) {
          tableContainer.innerHTML = '<div class="no-shifts">No shifts added yet. Add shifts using one of the methods above.</div>';
          return;
        }
        
        // Sort shifts by date
        const sortedShifts = [...shifts].sort((a, b) => a.date - b.date);
        
        let html = `
          <table class="shifts-table">
            <thead>
              <tr>
                <th>Date</th>
                <th>Times</th>
                <th>Hours</th>
                <th>Earnings</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
        `;
        
        sortedShifts.forEach(shift => {
          const dayName = shift.dayType.charAt(0).toUpperCase() + shift.dayType.slice(1);
          
          let timeInfo = `${shift.startTime} - ${shift.endTime}`;
          
          if (shift.includeBreak) {
            timeInfo += ` <span style="color:#718096">(break: ${shift.breakTime})</span>`;
          }
          
          // Add overtime info if applicable
          let hoursInfo = `${shift.duration.toFixed(2)}`;
          
          if (shift.includeOvertime && shift.overtimeDuration > 0) {
            hoursInfo += ` <span class="overtime-badge">${shift.overtimeDuration.toFixed(2)}h OT</span>`;
          }
          
          html += `
            <tr>
              <td>${formatDate(shift.date)} <span style="color:#718096">(${dayName})</span></td>
              <td>${timeInfo}</td>
              <td>${hoursInfo}</td>
              <td>${shift.earnings.toFixed(2)} kr</td>
              <td class="text-center">
                <button class="btn btn-sm" onclick="showShiftBreakdown(${shift.id})">Details</button>
                <button class="btn btn-sm btn-red" onclick="deleteShift(${shift.id})">×</button>
              </td>
            </tr>
          `;
        });
        
        html += `
            </tbody>
          </table>
        `;
        
        tableContainer.innerHTML = html;
      }
      
      // Update total amounts
      function updateTotals() {
        const totalEarnings = shifts.reduce((sum, shift) => sum + shift.earnings, 0);
        const totalHours = shifts.reduce((sum, shift) => sum + shift.duration, 0);
        const totalOvertimeHours = shifts.reduce((sum, shift) => sum + (shift.overtimeDuration || 0), 0);
        
        totalAmountEl.textContent = `${totalEarnings.toFixed(2)} kr`;
        totalHoursEl.textContent = `Total hours: ${totalHours.toFixed(2)}`;
        overtimeHoursEl.textContent = `Overtime hours: ${totalOvertimeHours.toFixed(2)}`;
      }
      
      // Make functions available globally for event handling
      window.deleteShift = deleteShift;
      window.showShiftBreakdown = showShiftBreakdown;
      
      // Add event listeners
      addShiftBtn.addEventListener('click', addShift);
      fetchCalendarBtn.addEventListener('click', fetchCalendar);
      calendarFileInput.addEventListener('change', handleCalendarFile);
      addCalendarShiftsBtn.addEventListener('click', addCalendarShifts);
      clearAllBtn.addEventListener('click', clearAllShifts);
    })();
  </script>

  <!-- Direct fix script for overtime input -->
  <script>
    // This script directly fixes the overtime hours input issue
    document.addEventListener('DOMContentLoaded', function() {
      // Get the elements
      const overtimeCheckbox = document.getElementById('overtimeCheck');
      const overtimeHoursInput = document.getElementById('overtimeHours');
      const overtimePositionSelect = document.getElementById('overtimePosition');
      
      // Add a direct event listener for the checkbox
      overtimeCheckbox.addEventListener('click', function() {
        console.log('Overtime checkbox clicked, checked:', this.checked);
        
        // Force enable/disable the inputs based on checkbox state
        overtimeHoursInput.disabled = !this.checked;
        overtimePositionSelect.disabled = !this.checked;
        
        // Try to remove any readonly attributes too
        if (this.checked) {
          overtimeHoursInput.removeAttribute('readonly');
          overtimePositionSelect.removeAttribute('readonly');
        }
      });
      
      // Check initial state and apply it
      if (overtimeCheckbox.checked) {
        overtimeHoursInput.disabled = false;
        overtimePositionSelect.disabled = false;
      }
      
      console.log('Fix script loaded');
    });
  </script>
</body>
</html>
